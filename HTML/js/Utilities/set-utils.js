function ReduceRequiredSet(items,test,breadthFirst=!1){for(var state=new ReduceRequiredSetState(items);state.AnyPartitions;){let rangeToSplit=breadthFirst?state.LargestRange:state.SmallestRange,mid=Math.floor((rangeToSplit.Item1+rangeToSplit.Item2)/2),split1=new InclusiveRange(rangeToSplit.Item1,mid),split2=new InclusiveRange(mid+1,rangeToSplit.Item2);state.ApplyTemporarySplit(rangeToSplit,split1),test(state)?(state.RemoveRange(rangeToSplit),state.AddRange(split1)):(state.ApplyTemporarySplit(rangeToSplit,split2),test(state)?(state.RemoveRange(rangeToSplit),state.AddRange(split2)):(state.ResetTemporarySplit(),state.RemoveRange(rangeToSplit),state.AddRange(split1),state.AddRange(split2)))}return state.ResetTemporarySplit(),state.SetToTest}class ReduceRequiredSetState{constructor(items){this.Items=items,this.Ranges=[],this.Ranges.push(new InclusiveRange(0,this.Items.length-1))}_MaxElement(arr,func){if(arr&&arr.length>0){let max=arr[0],mapped=arr.map(func),maxV=mapped[0];for(let i=1;i<arr.length;i++)mapped[i]>maxV&&(maxV=mapped[i],max=arr[i]);return max}return null}_MinElement(arr,func){if(arr&&arr.length>0){let min=arr[0],mapped=arr.map(func),minV=mapped[0];for(let i=1;i<arr.length;i++)mapped[i]<minV&&(minV=mapped[i],min=arr[i]);return min}return null}get DefinitelyRequired(){return this.Ranges.filter((r=>r.Item1==r.Item2)).map((r=>this.Items[r.Item1]))}get PartitionsCount(){return this.Ranges.length-this.Ranges.filter((r=>r.Item1==r.Item2)).length}get SmallestPartitionSize(){return Math.min(this.Ranges.filter((r=>r.Item1!=r.Item2)).map((r=>r.Item2-r.Item1+1)))}get LargestPartitionSize(){return Math.max(this.Ranges.map((r=>r.Item2-r.Item1+1)))}get ItemsRemaining(){return this.Ranges.filter((r=>r.Item1!=r.Item2)).map((r=>r.Item2-r.Item1+1)).reduce(((a,b)=>a+b),0)}get SetToTest(){let ranges=Array(this.Ranges.length);if(Object.assign(ranges,this.Ranges),this.ExcludedRange){let ex=this.ExcludedRange;ranges=ranges.filter((r=>!r.Equals(ex)))}if(this.IncludedRange){let inc=this.IncludedRange;ranges=ranges.concat(inc)}let a=[];return ranges.forEach(((r,i)=>{a=a.concat(r.Enumerate())})),a.sort((function(a,b){return a-b})),a.map((i=>this.Items[i]))}get AnyPartitions(){return this.Ranges.some((r=>r.Item1!=r.Item2))}get LargestRange(){return this._MaxElement(this.Ranges,(t=>t.Item2-t.Item1))}get SmallestRange(){return this._MinElement(this.Ranges.filter((r=>r.Item1!=r.Item2)),(t=>t.Item2-t.Item1))}AddRange(range){this.Ranges.push(range)}RemoveRange(range){let i=this.Ranges.findIndex((r=>r.Equals(range)));i>=0&&this.Ranges.splice(i,1)}ResetTemporarySplit(){this.ExcludedRange=this.IncludedRange=null}ApplyTemporarySplit(rangeToSplit,splitRange){this.ExcludedRange=rangeToSplit,this.IncludedRange=splitRange}}class InclusiveRange{constructor(item1,item2){this.Item1=item1,this.Item2=item2}Equals(obj){return null!=obj&&obj.Item1==this.Item1&&obj.Item2==this.Item2}Enumerate(){let start=this.Item1;return[...Array(this.Item2-this.Item1+1).keys()].map((x=>x+start))}}class CtRange{constructor(start,count){this.Start=start,this.Count=count}Equals(obj){return null!=obj&&obj.Start==this.Start&&obj.Count==this.Count}Enumerate(){let start=this.Start;return[...Array(this.Count).keys()].map((x=>x+start))}}